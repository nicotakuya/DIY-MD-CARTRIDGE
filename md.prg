'MEGADRIVE CARTRIDGE(FLASH MEMORY) WRITER for Pi STARTER
'BY TAKUYA MATSUBARA
ACLS
DIM SPIBUF%[3]

'KEYCODE
RIGHT = 28
LEFT  = 29
UP    = 30
DOWN  = 31
ENTER = 13
SPACE = 32
ESCAPE= &H1B

HIGH = 1
LOW  = 0
KILO = 1024
MEGA = 1024*1024
ADR2M = FLOOR(2*MEGA/8) 'ADDRESS
ADR4M = FLOOR(4*MEGA/8) 'ADDRESS
ADR8M = FLOOR(8*MEGA/8) 'ADDRESS

SAFE= #GPIO18 'GPIO NUMBER
RD  = #GPIO23 'GPIO NUMBER
ROM = #GPIO24 'GPIO NUMBER
WE  = #GPIO25 'GPIO NUMBER

CHIPSEL = ROM
ENABLE = RD

GPIOMODE SAFE,#GPIOMODE_OUT
GPIOMODE RD,#GPIOMODE_OUT
GPIOMODE ROM,#GPIOMODE_OUT
GPIOMODE WE,#GPIOMODE_OUT
GPIOOUT RD,HIGH
GPIOOUT ROM,HIGH
GPIOOUT WE,HIGH
GPIOOUT SAFE,LOW
MCP23S17INIT
'gosub @PINTEST:end

ROMBYTEMAX=ADR4M '4M
CHIPSIZE=ADR4M

DIM BINDATA[ROMBYTEMAX] 'ROM IMAGE
FILENAME$=""

WHILE 1
 PRINT ""
 PRINT "---MENU"
 PRINT "TARGET=FLASHROM";
 PRINT "(";2*ROMBYTEMAX*8/MEGA;" M bits)"
 PRINT " 1:READ ROM(256バイト よみこみテスト)"
 PRINT " 3:ERASE FLASH MEMORY(ROMのなかみを しょうきょ)"
 PRINT " 4:WRITE IMAGE TO ROM(ROMにイメージをかきこみ)"
 PRINT " 5:VERIIFY(ROMをよんでイメージとひかくする)"
 PRINT " 8:DUMP IMAGE FILE(イメージファイルをみる)"
' print " 9:write 1word"
 PRINT " 0:EXIT"
 INPUT "COMMAND";CMD
 IF CMD==1 THEN GOSUB @ROMREAD
 IF CMD==3 THEN GOSUB @FLASHCHIPERASE
 IF CMD==4 THEN GOSUB @ROMWRITE
 if CMD==5 then GOSUB @VERIFY
 IF CMD==8 THEN GOSUB @FILEDUMP
 IF CMD==0 THEN BREAK
WEND
CLS
END

'---
@oneword
GPIOOUT WE,HIGH  'DISABLE
GPIOOUT RD,HIGH  'DISABLE
GPIOOUT ROM,HIGH  'DISABLE
MCP23S17SETDATAMODE 1 '0:INPUT/1:OUTPUT
ROMADR=0
WRITEDATA=&h1234
FLASHWRITEWORD ROMADR,WRITEDATA
MCP23S17SETDATAMODE 0 '0:INPUT/1:OUTPUT

return

'---
@PINTEST
  FOR I=0 TO 100
   GPIOOUT ROM,LOW
   PRINT "ROM=LOW"
   WAIT 60*3
   GPIOOUT ROM,HIGH
   PRINT "ROM=HIGH"
   WAIT 60*3

   GPIOOUT RD,LOW
   PRINT "RD=LOW"
   WAIT 60*3
   GPIOOUT RD,HIGH
   PRINT "RD=HIGH"
   WAIT 60*3

   GPIOOUT WE,LOW
   PRINT "WE=LOW"
   WAIT 60*3
   GPIOOUT WE,HIGH
   PRINT "WE=HIGH"
   WAIT 60*3
  NEXT
RETURN

'---
@VERIFY
FILENAME$ = FILESELECT(0,".BIN")
IF FILENAME$=="" THEN RETURN

PRINT "VERIFY ROM"
PRINT "READ IMAGE FILE:";FILENAME$
LOAD "RAW:"+FILENAME$,BINDATA
PRINT "READ ";LEN(BINDATA);" BYTES(";LEN(BINDATA)*8/MEGA;"M BITS)"
PRINT "VERIFY..."

GPIOOUT RD,HIGH
GPIOOUT ROM,HIGH
GPIOOUT WE,HIGH
MCP23S17SETDATAMODE 0 '0:INPUT/1:OUTPUT

GPIOOUT CHIPSEL,LOW
USLEEP 50

WORK$=""
ERRFLAG=0
ROMADR=0
BINADR=0
WHILE 1
 IF BINADR>=LEN(BINDATA) THEN BREAK 'END OF FILE
 IF ROMADR>=ROMBYTEMAX THEN BREAK

 USLEEP 50
 MCP23S17SETADR ROMADR
 USLEEP 50
 GPIOOUT ENABLE,LOW 'ENABLE
 USLEEP 50
 READDATA = MCP23S17GETDATA()
 GPIOOUT ENABLE,HIGH 'ENABLE
 X = ROMADR MOD 8
' IF X==0 THEN
'  IF WORK$!="" THEN PRINT WORK$:WORK$=""
'  WORK$ = HEX$(ROMADR,8)+":"+(" "*64)
'  IF (ROMADR AND &HFF)==0 THEN PRINT FLOOR(BINADR*100/LEN(BINDATA));"%"
' ENDIF
' WORK$ = SUBST$(WORK$,9+(X*5),4,HEX$(READDATA,4))

' TMP=(16*3+9)+(X*2)
' WORK$ = SUBST$(WORK$,TMP  ,1,CODE2CHR(READDATA >> 8)) 'じょうい
' WORK$ = SUBST$(WORK$,TMP+1,1,CODE2CHR(READDATA and &HFF)) 'かい

 TMP = (BINDATA[BINADR]<<8) + BINDATA[BINADR+1]
 IF READDATA != TMP THEN
  ERRFLAG = ERRFLAG+1
  PRINT "ERR";ERRFLAG;
  PRINT " ADR=";HEX$(ROMADR);" NG=";HEX$(READDATA,4);":OK=";HEX$(TMP,4)
 ENDIF

 ROMADR=ROMADR+1
 BINADR=BINADR+2
WEND
'IF WORK$!="" THEN PRINT WORK$:WORK$=""
GPIOOUT ENABLE,HIGH
GPIOOUT CHIPSEL,HIGH

if ERRFLAG THEN
 PRINT "NG"
ELSE
 PRINT "OK!"
ENDIF

RETURN

'---
@ROMREAD
GPIOOUT RD,HIGH
GPIOOUT ROM,HIGH
GPIOOUT WE,HIGH
MCP23S17SETDATAMODE 0 '0:INPUT/1:OUTPUT
PRINT "READ ROM 256 BYTES"
A$=""
INPUT "ADDRESS(HEX):";A$
IF A$=="" THEN A$="000000"
ROMADR=VAL("&H"+A$)
GPIOOUT CHIPSEL,LOW
USLEEP 50

WORK$ = ""
FOR I=&H00 TO &HFF
 USLEEP 50
 MCP23S17SETADR ROMADR
 USLEEP 50
 GPIOOUT ENABLE,LOW 'ENABLE
 USLEEP 50
 READDATA = MCP23S17GETDATA()
 GPIOOUT ENABLE,HIGH 'ENABLE
 X = ROMADR MOD 8
 IF X==0 THEN
  IF WORK$!="" THEN PRINT WORK$:WORK$=""
  WORK$ = HEX$(ROMADR,8)+":"+(" "*64)
 ENDIF
 WORK$ = SUBST$(WORK$,9+(X*5),4,HEX$(READDATA,4))

 TMP=(16*3+9)+(X*2)
 WORK$ = SUBST$(WORK$,TMP  ,1,CODE2CHR(READDATA >> 8)) 'じょうい
 WORK$ = SUBST$(WORK$,TMP+1,1,CODE2CHR(READDATA and &HFF)) 'かい
 ROMADR=ROMADR+1
NEXT
IF WORK$!="" THEN PRINT WORK$:WORK$=""
GPIOOUT ENABLE,HIGH
GPIOOUT CHIPSEL,HIGH
RETURN

'---
@ROMWRITE
FILENAME$ = FILESELECT(0,".BIN")
IF FILENAME$=="" THEN RETURN

PRINT "WRITE IMAGE TO ROM"
PRINT "READ IMAGE FILE:";FILENAME$
LOAD "RAW:"+FILENAME$,BINDATA
PRINT "READ ";LEN(BINDATA);" BYTES(";LEN(BINDATA)*8/MEGA;"M BITS)"

GPIOOUT WE,HIGH  'DISABLE
GPIOOUT RD,HIGH  'DISABLE
GPIOOUT ROM,HIGH  'DISABLE
MCP23S17SETDATAMODE 1 '0:INPUT/1:OUTPUT

IF INPUTYN()==ASC("N") THEN RETURN
PRINT
Y=360/8-1
LOCATE 1,Y
PRINT "WRITE ADR:";
LOCATE 20,Y
PRINT "/";HEX$((LEN(BINDATA)/2)-1);
ERRFLAG=0
STARTCNT=MAINCNT

WORK$ = ""
ROMADR=0
BINADR=0
WHILE 1
 IF BINADR>=LEN(BINDATA) THEN BREAK 'END OF FILE
 IF ROMADR>=ROMBYTEMAX THEN BREAK

 WRITEDATA = BINDATA[BINADR]<<8 'じょうい
 BINADR = BINADR+1
 WRITEDATA = WRITEDATA + BINDATA[BINADR] 'かい
 BINADR = BINADR+1

 FLASHWRITEWORD ROMADR,WRITEDATA

' X = ROMADR MOD 8
' IF X==0 THEN
'  IF WORK$!="" THEN PRINT WORK$:WORK$=""
'  WORK$ = HEX$(ROMADR,8)+":"+(" "*64)
 IF (ROMADR AND &HFF)==0 THEN
  LOCATE 12,Y
  PRINT HEX$(ROMADR);
  LOCATE 30,Y
  PRINT "(";FLOOR(BINADR*100/LEN(BINDATA));"%)";
 ENDIF
' ENDIF
' WORK$ = SUBST$(WORK$,9+(X*5),4,HEX$(WRITEDATA,4))
 IF ERRFLAG THEN RETURN
 ROMADR = ROMADR+1
WEND
'IF WORK$!="" THEN PRINT WORK$:WORK$=""
MCP23S17SETDATAMODE 0 '0:INPUT/1:OUTPUT

IF ERRFLAG THEN RETURN

LOCATE 12,Y
PRINT HEX$(ROMADR-1);
LOCATE 30,Y
PRINT "(";FLOOR(BINADR*100/LEN(BINDATA));"%)";

PRINT
PRINT "COMPLETE"
WORKTIME=FLOOR((MAINCNT-STARTCNT)/(60*60))
PRINT "RUNNING TIME:";WORKTIME;" MINUTE"
RETURN

'---
@FLASHCHIPERASE

PRINT "FLASH MEMORY CHIP ERASE"

IF INPUTYN()==ASC("N") THEN RETURN

FOR ROMADR=0 TO ROMBYTEMAX-1 STEP CHIPSIZE
 PRINT "ADDRESS ";HEX$(ROMADR);" - ";HEX$(ROMADR+CHIPSIZE-1)
 FLASHCHIPERASESUB ROMADR
NEXT
RETURN

'---
DEF CODE2CHR(CHRNUM)
 IF CHRNUM>=&H20 AND CHRNUM<=&H7F THEN
  return(CHR$(CHRNUM))
 ELSE
  return(".")
 ENDIF
END

'---
DEF FLASHWRITEWORD ROMADR,WRITEDATA
 IF WRITEDATA==&HFFFF THEN RETURN
 CHIPADR=FLOOR(ROMADR/CHIPSIZE)*CHIPSIZE '
 GPIOOUT RD,HIGH  'DISABLE
 GPIOOUT WE,HIGH  'DISABLE
 GPIOOUT ROM,HIGH 'DISABLE
 CLKWAIT
 GPIOOUT CHIPSEL,LOW 'ENABLE

 'SST39SF040
 SETADR_DATA CHIPADR+&H5555,&HAAAA 'CYCLE1
 SETWECLK
 SETADR_DATA CHIPADR+&H2AAA,&H5555 'CYCLE2
 SETWECLK
 SETADR_DATA CHIPADR+&H5555,&HA0A0 'CYCLE3
 SETWECLK
 SETADR_DATA ROMADR,WRITEDATA   'CYCLE4
 SETWECLK

 GPIOOUT CHIPSEL,HIGH  'DISABLE
 CLKWAIT
END

'---
DEF FLASHCHIPERASESUB ROMADR
CHIPADR = FLOOR(ROMADR/CHIPSIZE)*CHIPSIZE '
MCP23S17SETDATAMODE 1 '0:INPUT/1:OUTPUT

GPIOOUT ENABLE,LOW 'ENABLE
GPIOOUT WE,HIGH    'DISABLE
GPIOOUT RD,HIGH    'DISABLE
CLKWAIT
SETADR_DATA CHIPADR+&H5555,&HAAAA 'CYCLE1
GPIOOUT CHIPSEL,LOW 'ENABLE
CLKWAIT
GPIOOUT ENABLE,HIGH
CLKWAIT
SETWECLK 'WE=LOW-->HIGH
GPIOOUT CHIPSEL,HIGH
SETADR_DATA CHIPADR+&H2AAA,&H5555 'CYCLE2
GPIOOUT CHIPSEL,LOW
SETWECLK 'WE=LOW-->HIGH
SETADR_DATA CHIPADR+&H5555,&H8080 'CYCLE3
SETWECLK 'WE=LOW-->HIGH
SETADR_DATA CHIPADR+&H5555,&HAAAA 'CYCLE4
SETWECLK 'WE=LOW-->HIGH
SETADR_DATA CHIPADR+&H2AAA,&H5555 'CYCLE5
SETWECLK 'WE=LOW-->HIGH
SETADR_DATA CHIPADR+&H5555,&H1010 'CYCLE6
SETWECLK 'WE=LOW-->HIGH

FOR I=1 TO 30
 PRINT " ";I;"/30"
 WAIT 60
NEXT
GPIOOUT CHIPSEL,HIGH  'DISABLE
GPIOOUT ENABLE,HIGH
MCP23S17SETDATAMODE 0 '0:INPUT/1:OUTPUT
PRINT "しょきか かんりょう"

END

'---
DEF SETADR_DATA ROMADR,WRITEDATA
 MCP23S17SETADR ROMADR
 MCP23S17SETDATA WRITEDATA
END

'---
DEF SETWECLK
 USLEEP 10
 GPIOOUT WE,LOW  'ENABLE
 USLEEP 30
 GPIOOUT WE,HIGH  'DISABLE
 USLEEP 20
END

'---
DEF MCP23S17GETDATA()
 MCP23S17RECV 2,&H13 ' CHIP2:B
 GETW=SPIBUF%[2]
 MCP23S17RECV 2,&H12 ' CHIP2:A
 GETW=(GETW << 8)+SPIBUF%[2]
 RETURN(GETW)
END

'---
DEF MCP23S17SETDATA DAT
 MCP23S17SEND 2,&H12,(DAT AND &HFF)'CHIP2 GPIOA かい8bit
 MCP23S17SEND 2,&H13,(DAT >> 8)    'CHIP2 GPIOB じょうい8bit
END

'---
DEF MCP23S17SETADR WORKADR
 MCP23S17SEND 0,&H12,(WORKADR AND &HFF)       'A00-07 CHIP0:A
 MCP23S17SEND 0,&H13,((WORKADR>>8) AND &HFF)  'A08-15 CHIP0:B
 MCP23S17SEND 1,&H12,((WORKADR>>16) AND &HFF) 'A16-23 CHIP1:A
END

'---
DEF MCP23S17SETDATAMODE D '0:INPUT/1:OUTPUT
 IF D THEN
  MCP23S17SEND 2,&H00,&H00 'CHIP2 IODIRA OUTPUT
  MCP23S17SEND 2,&H01,&H00 'CHIP2 IODIRB OUTPUT
 ELSE
  MCP23S17SEND 2,&H00,&HFF 'CHIP2 IODIRA INPUT
  MCP23S17SEND 2,&H01,&HFF 'CHIP2 IODIRB INPUT
 ENDIF
END

'---
DEF MCP23S17INIT
' F=600000 'SPI クロック(HZ)
' F=800000 'SPI クロック(HZ)
 F=400000 'SPI クロック(HZ)
' T=0 'タイミング CPOL=0,CPHA=0
 T=1 'タイミング CPOL=0,CPHA=1
' T=2 'タイミング CPOL=1,CPHA=0
' T=3 'タイミング CPOL=1,CPHA=1

 SPISTART F,T
 WAIT 15

 MCP23S17SEND 0,&H0A,&H28  'CHIP0 IOCON
 '  BANK/MIRROR/SEQOP    /DISSLW  /HAEN    /ODR     /INTPOL  /0
 '  0   /0     /1=disable/0=enable/1=enable/0=active/0=lowact/0
 
 MCP23S17SEND 0,&H00,&H00 'CHIP0 IODIRA OUTPUT
 MCP23S17SEND 0,&H01,&H00 'CHIP0 IODIRB OUTPUT

 MCP23S17SEND 1,&H00,&H00 'CHIP1 IODIRA OUTPUT
 MCP23S17SEND 1,&H01,&HFF 'CHIP1 IODIRB INPUT

 MCP23S17SEND 2,&H00,&HFF 'CHIP2 IODIRA INPUT
 MCP23S17SEND 2,&H01,&HFF 'CHIP2 IODIRB INPUT

 MCP23S17SEND 0,&H12,&H00 'CHIP0 GPIOA
 MCP23S17SEND 0,&H13,&H00 'CHIP0 GPIOB

 MCP23S17SEND 1,&H12,&H00 'CHIP1 GPIOA
 MCP23S17SEND 1,&H13,&H00 'CHIP1 GPIOB

 MCP23S17SEND 2,&H12,&H00 'CHIP2 GPIOA
 MCP23S17SEND 2,&H13,&H00 'CHIP2 GPIOB
END

'---
DEF MCP23S17SEND CHIP,ADDRESS, DAT
 SPIBUF%[0]=&H40+(CHIP<<1)
 SPIBUF%[1]=ADDRESS
 SPIBUF%[2]=DAT
 SPISEND SPIBUF%,3
 CLKWAIT
END

'---
DEF MCP23S17RECV CHIP,ADDRESS
 SPIBUF%[0]=&H40+(CHIP<<1)+1
 SPIBUF%[1]=ADDRESS
 SPIBUF%[2]=0
 SPISENDRECV SPIBUF%,3
 CLKWAIT
END

'---
DEF CLKWAIT
' USLEEP 50
 USLEEP 20
END

'---
@FILEDUMP
FILENAME$ = FILESELECT(0,".BIN")
IF FILENAME$=="" THEN RETURN

PRINT "IMAGE FILE DUMP"
PRINT "FILE NAME:";FILENAME$

LOAD "RAW:"+FILENAME$,BINDATA
PRINT "READ ";LEN(BINDATA);" BYTES(";LEN(BINDATA)*8/MEGA;"M BITS)"
A$=""
INPUT "ADDRESS(HEX):";A$
IF A$=="" THEN A$="000000"
ROMADR=VAL("&H"+A$)
WORK$=""
FOR I=0 TO &H1FF
 IF ROMADR>=LEN(BINDATA) THEN BREAK
 X = ROMADR MOD 16
 WRITEDATA = BINDATA[ROMADR]
 IF X==0 THEN
  IF WORK$!="" THEN PRINT WORK$:WORK$=""
  WORK$ = HEX$(ROMADR,8)+":"+(" "*64)
 ENDIF
 WORK$ = SUBST$(WORK$,9+(X*3),2,HEX$(WRITEDATA,2))

 TMP=9+(16*3)+X
 WORK$ = SUBST$(WORK$,TMP,1,CODE2CHR(WRITEDATA))
 ROMADR=ROMADR+1
NEXT
IF WORK$!="" THEN PRINT WORK$:WORK$=""

RETURN

'---
DEF HEXBYTE(ADR)
 RETURN(HEX$(BINDATA[BASEADR+ADR],2))
END

'---
DEF FILESELECT(DIRFLAG,FILTER$)

DIM NAME$[0]
DIM NAME2$[0]
COLOR #WHITE,0
CLS

FILTER$=UCASE(FILTER$)

FP=48
FH=20

PATH$=CHDIR()
SELPATH$=PATH$
OFX=0
OFY=0

LOCATE 1,FH+4
PRINT "[UP][DOWN]:カ-ソルいどう / [SPACE]:けってい / [ESC]:CANCEL"

WHILE 1
 COLOR #BLACK,#BLUE
 FOR I=0 TO FH+1+2
  LOCATE OFX,OFY+I
  PRINT " "*(FP+2)
 NEXT
 COLOR #WHITE,0
 FOR I=0 TO FH-1
  LOCATE OFX+1,OFY+I+1+2
  PRINT " "*FP
 NEXT
 
 LOCATE OFX+1,OFY+1
 PRINT "DIR:";SELPATH$

 IF FILTER$!="" THEN
  LOCATE OFX+38,OFY+1
  PRINT "FILTER:";FILTER$
 ENDIF
 WHILE LEN(NAME2$)
  R$=POP(NAME2$)
 WEND
 FILES SELPATH$,NAME$
 FOR I=0 TO LEN(NAME$)-1
  T$=NAME$[I]
  KAK$=RIGHT$(T$,4)
  IF UCASE(KAK$)==".PRG" THEN CONTINUE
  IF MID$(T$,1,1)=="@" THEN CONTINUE
  IF DIRFLAG==0 THEN
   IF LEFT$(T$,1)!="+" THEN
    IF FILTER$!="" AND INSTR(UCASE(T$),FILTER$)<0 THEN CONTINUE
   ENDIF
  ELSE
   IF LEFT$(T$,1)!="+" THEN CONTINUE
  ENDIF
  PUSH NAME2$,T$
 NEXT
 UNSHIFT NAME2$,"+.."

 IF DIRFLAG THEN
  PUSH NAME2$,"["+SELPATH$+"にけってい]"
  IDX=LEN(NAME2$)-1
 ELSE
  IDX=0
 ENDIF

 IDXOFS=0
 WHILE 1
  FOR I=0 TO LEN(NAME2$)-1
   X=OFX+1
   Y=(I-IDXOFS)
   IF Y<0 THEN CONTINUE
   IF Y>=FH THEN BREAK
   Y=Y+OFY+1+2
   LOCATE X,Y
   T$=" "*FP
   T$=SUBST$(T$,0,LEN(NAME2$[I]),NAME2$[I])
   IF IDX==I THEN COLOR 0,#WHITE ELSE COLOR #WHITE,0
   PRINT T$;
  NEXT
  COLOR #WHITE,0

  BT=KEYWAIT()
  IF BT==SPACE THEN BREAK
  IF BT==ENTER THEN BREAK
  IF BT==UP    THEN DEC IDX
  IF BT==DOWN  THEN INC IDX
  IF BT==ESCAPE THEN IDX=-1:BREAK

  IDX=FIXNUM(IDX,0,LEN(NAME2$)-1)

  WHILE IDXOFS>IDX
   DEC IDXOFS
  WEND
  WHILE (IDXOFS+FH-1)<IDX
   INC IDXOFS
  WEND
 WEND
 LOCATE 1,FH+4
 PRINT " "*80

 IF IDX<0 THEN SELPATH$="":BREAK

 NB$=MID$(NAME2$[IDX],0,1)
 NA$=MID$(NAME2$[IDX],1,999)
 IF DIRFLAG==0 THEN
  IF NB$!="+" THEN
   IF RIGHT$(SELPATH$,1)!="/" THEN SELPATH$=SELPATH$+"/"
   RETURN (SELPATH$+NA$)
  ENDIF
 ELSE
  IF IDX==LEN(NAME2$)-1 THEN BREAK
 ENDIF

 IF NA$==".." THEN
  TMP=1
  WHILE 1
   IF LEFT$(RIGHT$(SELPATH$,TMP),1)=="/" THEN BREAK
   INC TMP
  WEND
  SELPATH$=LEFT$(SELPATH$,LEN(SELPATH$)-TMP)
  IF LEFT$(SELPATH$,1)!="/" THEN SELPATH$="/"+SELPATH$
 ELSE
  IF RIGHT$(SELPATH$,1)!="/" THEN SELPATH$=SELPATH$+"/"
  SELPATH$=SELPATH$+NA$
 ENDIF
WEND
RETURN SELPATH$
END

'---
DEF LCASE(TMP$)
 FOR TMPI=0 TO LEN(TMP$)-1
  TMPC=ASC(MID$(TMP$,TMPI,1))
  IF TMPC>=&H41 AND TMPC<=&H5A THEN
   TMP$=SUBST$(TMP$,TMPI,1,CHR$(TMPC+&H20))
  ENDIF
 NEXT
 RETURN TMP$
END

'---
DEF UCASE(TMP$)
 FOR TMPI=0 TO LEN(TMP$)-1
  TMPC=ASC(MID$(TMP$,TMPI,1))
  IF TMPC>=&H61 AND TMPC<=&H7A THEN
   TMP$=SUBST$(TMP$,TMPI,1,CHR$(TMPC-&H20))
  ENDIF
 NEXT
 RETURN TMP$
END

'---
DEF KEYWAIT()
 BT=0
 WHILE BT==0
  VSYNC 1
  NOWKEY$=INKEY$()
  IF NOWKEY$ != "" THEN BT=ASC(NOWKEY$)
 WEND
 WHILE 1
  VSYNC 2
  IF INKEY$=="" THEN BREAK 'KEY BUFF CLEAR
 WEND
 IF BT>=&H60 AND BT<=&H7A THEN BT=BT-&H20 'UCASE
 RETURN BT
END

'---
DEF SWOFFWAIT
 WHILE 1
  VSYNC 1
  IF INKEY$=="" THEN BREAK
 WEND
END

'---
DEF INPUTYN()
 PRINT
 COLOR #BLACK,#WHITE
 PRINT " よろしいですか? [Y]/[N] ";
 COLOR #WHITE,0
 WHILE 1
  YN=KEYWAIT()
  IF YN==ASC("Y") THEN PRINT " YES":BREAK
  IF YN==ASC("N") THEN PRINT " NO":BREAK
 WEND
 WAIT 30
 RETURN YN
END

'---
DEF FIXNUM(NUM,MINNUM,MAXNUM)
 IF NUM<MINNUM THEN NUM=MINNUM
 IF NUM>MAXNUM THEN NUM=MAXNUM
 RETURN NUM
END

